#include "mptest/_cpack/mptest.h"
#include "re.h"

mptest__result assert_cc_match(const char *regex, const char *spec, int invert);

/*T Generated by `unicode_data.py gen_ascii_charclasses test` */

TEST(cls_named_alnum)
{
  return assert_cc_match("[[:alnum:]]", "0x30 0x39,0x41 0x5A,0x61 0x7A", 0);
}

TEST(cls_named_alnum_invert)
{
  return assert_cc_match("[[:^alnum:]]", "0x30 0x39,0x41 0x5A,0x61 0x7A", 1);
}

TEST(cls_named_alpha)
{
  return assert_cc_match("[[:alpha:]]", "0x41 0x5A,0x61 0x7A", 0);
}

TEST(cls_named_alpha_invert)
{
  return assert_cc_match("[[:^alpha:]]", "0x41 0x5A,0x61 0x7A", 1);
}

TEST(cls_named_ascii) { return assert_cc_match("[[:ascii:]]", "0x0 0x7F", 0); }

TEST(cls_named_ascii_invert)
{
  return assert_cc_match("[[:^ascii:]]", "0x0 0x7F", 1);
}

TEST(cls_named_blank)
{
  return assert_cc_match("[[:blank:]]", "0x9 0x9,0x20 0x20", 0);
}

TEST(cls_named_blank_invert)
{
  return assert_cc_match("[[:^blank:]]", "0x9 0x9,0x20 0x20", 1);
}

TEST(cls_named_cntrl)
{
  return assert_cc_match("[[:cntrl:]]", "0x0 0x1F,0x7F 0x7F", 0);
}

TEST(cls_named_cntrl_invert)
{
  return assert_cc_match("[[:^cntrl:]]", "0x0 0x1F,0x7F 0x7F", 1);
}

TEST(cls_named_digit)
{
  return assert_cc_match("[[:digit:]]", "0x30 0x30,0x39 0x39", 0);
}

TEST(cls_named_digit_invert)
{
  return assert_cc_match("[[:^digit:]]", "0x30 0x30,0x39 0x39", 1);
}

TEST(cls_named_graph)
{
  return assert_cc_match("[[:graph:]]", "0x21 0x21,0x7E 0x7E", 0);
}

TEST(cls_named_graph_invert)
{
  return assert_cc_match("[[:^graph:]]", "0x21 0x21,0x7E 0x7E", 1);
}

TEST(cls_named_lower)
{
  return assert_cc_match("[[:lower:]]", "0x61 0x61,0x7A 0x7A", 0);
}

TEST(cls_named_lower_invert)
{
  return assert_cc_match("[[:^lower:]]", "0x61 0x61,0x7A 0x7A", 1);
}

TEST(cls_named_print) { return assert_cc_match("[[:print:]]", "0x20 0x7E", 0); }

TEST(cls_named_print_invert)
{
  return assert_cc_match("[[:^print:]]", "0x20 0x7E", 1);
}

TEST(cls_named_punct)
{
  return assert_cc_match(
      "[[:punct:]]", "0x21 0x2F,0x3A 0x40,0x5B 0x60,0x7B 0x7E", 0);
}

TEST(cls_named_punct_invert)
{
  return assert_cc_match(
      "[[:^punct:]]", "0x21 0x2F,0x3A 0x40,0x5B 0x60,0x7B 0x7E", 1);
}

TEST(cls_named_space)
{
  return assert_cc_match("[[:space:]]", "0x9 0xD,0x20 0x20", 0);
}

TEST(cls_named_space_invert)
{
  return assert_cc_match("[[:^space:]]", "0x9 0xD,0x20 0x20", 1);
}

TEST(cls_named_perl_space)
{
  return assert_cc_match("[[:perl_space:]]", "0x9 0xA,0xC 0xD,0x20 0x20", 0);
}

TEST(cls_named_perl_space_invert)
{
  return assert_cc_match("[[:^perl_space:]]", "0x9 0xA,0xC 0xD,0x20 0x20", 1);
}

TEST(cls_named_upper)
{
  return assert_cc_match("[[:upper:]]", "0x41 0x41,0x5A 0x5A", 0);
}

TEST(cls_named_upper_invert)
{
  return assert_cc_match("[[:^upper:]]", "0x41 0x41,0x5A 0x5A", 1);
}

TEST(cls_named_word)
{
  return assert_cc_match("[[:word:]]", "0x30 0x39,0x41 0x5A,0x61 0x7A", 0);
}

TEST(cls_named_word_invert)
{
  return assert_cc_match("[[:^word:]]", "0x30 0x39,0x41 0x5A,0x61 0x7A", 1);
}

TEST(cls_named_xdigit)
{
  return assert_cc_match("[[:xdigit:]]", "0x30 0x39,0x41 0x46,0x61 0x66", 0);
}

TEST(cls_named_xdigit_invert)
{
  return assert_cc_match("[[:^xdigit:]]", "0x30 0x39,0x41 0x46,0x61 0x66", 1);
}

SUITE(cls_named)
{
  RUN_TEST(cls_named_alnum);
  RUN_TEST(cls_named_alnum_invert);
  RUN_TEST(cls_named_alpha);
  RUN_TEST(cls_named_alpha_invert);
  RUN_TEST(cls_named_ascii);
  RUN_TEST(cls_named_ascii_invert);
  RUN_TEST(cls_named_blank);
  RUN_TEST(cls_named_blank_invert);
  RUN_TEST(cls_named_cntrl);
  RUN_TEST(cls_named_cntrl_invert);
  RUN_TEST(cls_named_digit);
  RUN_TEST(cls_named_digit_invert);
  RUN_TEST(cls_named_graph);
  RUN_TEST(cls_named_graph_invert);
  RUN_TEST(cls_named_lower);
  RUN_TEST(cls_named_lower_invert);
  RUN_TEST(cls_named_print);
  RUN_TEST(cls_named_print_invert);
  RUN_TEST(cls_named_punct);
  RUN_TEST(cls_named_punct_invert);
  RUN_TEST(cls_named_space);
  RUN_TEST(cls_named_space_invert);
  RUN_TEST(cls_named_perl_space);
  RUN_TEST(cls_named_perl_space_invert);
  RUN_TEST(cls_named_upper);
  RUN_TEST(cls_named_upper_invert);
  RUN_TEST(cls_named_word);
  RUN_TEST(cls_named_word_invert);
  RUN_TEST(cls_named_xdigit);
  RUN_TEST(cls_named_xdigit_invert);
}

TEST(escape_perlclass_D)
{
  return assert_cc_match("\\D", "0x0 0x2F,0x31 0x38,0x3A 0x10FFFF", 0);
}

TEST(escape_perlclass_d)
{
  return assert_cc_match("\\d", "0x30 0x30,0x39 0x39", 0);
}

TEST(escape_perlclass_S)
{
  return assert_cc_match("\\S", "0x0 0x8,0xB 0xB,0xE 0x1F,0x21 0x10FFFF", 0);
}

TEST(escape_perlclass_s)
{
  return assert_cc_match("\\s", "0x9 0xA,0xC 0xD,0x20 0x20", 0);
}

TEST(escape_perlclass_W)
{
  return assert_cc_match(
      "\\W", "0x0 0x2F,0x3A 0x40,0x5B 0x60,0x7B 0x10FFFF", 0);
}

TEST(escape_perlclass_w)
{
  return assert_cc_match("\\w", "0x30 0x39,0x41 0x5A,0x61 0x7A", 0);
}

SUITE(escape_perlclass)
{
  RUN_TEST(escape_perlclass_D);
  RUN_TEST(escape_perlclass_d);
  RUN_TEST(escape_perlclass_S);
  RUN_TEST(escape_perlclass_s);
  RUN_TEST(escape_perlclass_W);
  RUN_TEST(escape_perlclass_w);
}

/*t Generated by `unicode_data.py gen_ascii_charclasses test` */

/*T Generated by `unicode_data.py gen_parser_fuzz_regression_tests` */
TEST(fuzz_regression_0000)
{
  re *r;
  int err = re_init_full(&r, "[\\sR", 4, NULL);
  if (err == ERR_MEM)
    goto oom;
  ASSERT_EQ(err, ERR_PARSE);
  re_destroy(r);
  PASS();
oom:
  re_destroy(r);
  OOM();
}

TEST(fuzz_regression_0001)
{
  re *r;
  int err = re_init_full(&r, "6&666{66", 8, NULL);
  if (err == ERR_MEM)
    goto oom;
  ASSERT_EQ(err, ERR_PARSE);
  re_destroy(r);
  PASS();
oom:
  re_destroy(r);
  OOM();
}

TEST(fuzz_regression_0002)
{
  re *r;
  int err = re_init_full(&r, "...{66,", 7, NULL);
  if (err == ERR_MEM)
    goto oom;
  ASSERT_EQ(err, ERR_PARSE);
  re_destroy(r);
  PASS();
oom:
  re_destroy(r);
  OOM();
}

TEST(fuzz_regression_0003)
{
  re *r;
  int err = re_init_full(&r, ".\x00\x0C~.~G.q\x00\x00[\\w]\\\x00", 17, NULL);
  if (err == ERR_MEM)
    goto oom;
  ASSERT_EQ(err, ERR_PARSE);
  re_destroy(r);
  PASS();
oom:
  re_destroy(r);
  OOM();
}

TEST(fuzz_regression_0004)
{
  re *r;
  int err = re_init_full(
      &r,
      "[[:^word:][:^word:][:^word:][:^word:]\\\\9[:^word:][:^word:][:^cntrl:][:"
      "^w||||||||||||||||||||||||||\x80\x83\x83\x83\x83\x83\x83\x83|||ord:]",
      114, NULL);
  if (err == ERR_MEM)
    goto oom;
  ASSERT_EQ(err, ERR_PARSE);
  re_destroy(r);
  PASS();
oom:
  re_destroy(r);
  OOM();
}

TEST(fuzz_regression_0005)
{
  re *r;
  int err = re_init_full(&r, "\x00++++++++++++++++++++++++++++++++", 33, NULL);
  if (err == ERR_MEM)
    goto oom;
  ASSERT_EQ(err, 0);
  if ((err = re_match(r, "", 0, 0, 0, NULL, NULL, 'U')) == ERR_MEM)
    goto oom;
  re_destroy(r);
  PASS();
oom:
  re_destroy(r);
  OOM();
}

TEST(fuzz_regression_0006)
{
  re *r;
  int err = re_init_full(
      &r,
      "[^[\x00+\x01\x01\\d\x00\\S2S-\x01\x00]+\x05++++++++"
      "\x00\x00\x00\x00\x00\x00\x00\ta\x00#++",
      41, NULL);
  if (err == ERR_MEM)
    goto oom;
  ASSERT_EQ(err, 0);
  if ((err = re_match(r, "", 0, 0, 0, NULL, NULL, 'U')) == ERR_MEM)
    goto oom;
  re_destroy(r);
  PASS();
oom:
  re_destroy(r);
  OOM();
}

SUITE(fuzz_regression)
{
  RUN_TEST(fuzz_regression_0000);
  RUN_TEST(fuzz_regression_0001);
  RUN_TEST(fuzz_regression_0002);
  RUN_TEST(fuzz_regression_0003);
  RUN_TEST(fuzz_regression_0004);
  RUN_TEST(fuzz_regression_0005);
  RUN_TEST(fuzz_regression_0006);
}

/*t Generated by `unicode_data.py gen_parser_fuzz_regression_tests` */
